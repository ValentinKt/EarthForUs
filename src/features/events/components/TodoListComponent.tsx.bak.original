import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { api } from '../../../shared/utils/api';
import { logger } from '../../../shared/utils/logger';
import { useToast } from '../../../shared/components/Toast';
import Button from '../../../shared/ui/Button';

type TodoItem = {
  id: number;
  event_id: number;
  title: string;
  description?: string | null;
  is_completed: boolean;
  created_at: string;
  updated_at: string;
  created_by: number;
  assigned_to?: number | null;
  priority: 'low' | 'medium' | 'high';
  due_date?: string | null;
};

type TodoListComponentProps = {
  eventId: number;
  currentUserId?: number;
  currentUserName?: string;
  isOrganizer?: boolean;
};

const TodoListComponent: React.FC<TodoListComponentProps> = ({ 
  eventId, 
  currentUserId, 
  isOrganizer = false 
}) => {
  const [todos, setTodos] = useState<TodoItem[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [showAddForm, setShowAddForm] = useState(false);
  const [newTodo, setNewTodo] = useState({ 
    title: '', 
    description: '', 
    priority: 'medium' as TodoItem['priority'],
    due_date: '',
    tagsInput: ''
  });
  const [isCreating, setIsCreating] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [sortBy, setSortBy] = useState<'priority' | 'due_date' | 'created_at'>('priority');
  const [editingTodoId, setEditingTodoId] = useState<number | null>(null);
  const [editValues, setEditValues] = useState<{ title: string; description: string; priority: TodoItem['priority']; due_date: string } | null>(null);
  const { error: showError, success: showSuccess } = useToast();
  const log = logger.withContext('TodoListComponent');

  // Local tags cache: todoId -> [tags]
  const [tagsByTodoId, setTagsByTodoId] = useState<Record<number, string[]>>({});
  const persistTimerRef = useRef<number | null>(null);
  const reminderTimersRef = useRef<Record<number, number>>({});

  const todosCacheKey = useMemo(() => `earthforus:event:${eventId}:todosCache`, [eventId]);
  const tagsCacheKey = useMemo(() => `earthforus:event:${eventId}:tagsCache`, [eventId]);

  

  const persistTodosCache = useCallback((nextTodos: TodoItem[]) => {
    // Debounce localStorage writes
    if (persistTimerRef.current) {
      window.clearTimeout(persistTimerRef.current);
    }
    persistTimerRef.current = window.setTimeout(() => {
      try {
        localStorage.setItem(todosCacheKey, JSON.stringify(nextTodos));
      } catch (err) {
        log.warn('local_cache_write_error', { err });
      }
    }, 250);
  }, [todosCacheKey, log]);

  const persistTagsCache = useCallback((nextTags: Record<number, string[]>) => {
    try {
      localStorage.setItem(tagsCacheKey, JSON.stringify(nextTags));
    } catch (err) {
      log.warn('tags_cache_write_error', { err });
    }
  }, [tagsCacheKey, log]);

  const fetchTodos = useCallback(async () => {
    try {
      const data = await api.get<unknown>(`/api/events/${eventId}/todos`);
      let nextTodos: TodoItem[] = [];
      if (Array.isArray(data)) {
        nextTodos = data as TodoItem[];
      } else if (data && typeof data === 'object' && 'todos' in (data as Record<string, unknown>)) {
        const raw = (data as { todos: Array<{ id: number; title: string; description?: string | null; priority: 'low' | 'medium' | 'high'; dueDate?: string | null; isCompleted: boolean; createdAt: string; updatedAt: string; createdBy?: { id: number } }> }).todos || [];
        nextTodos = raw.map((t) => ({
          id: t.id,
          event_id: eventId,
          title: t.title,
          description: t.description ?? null,
          is_completed: !!t.isCompleted,
          created_at: t.createdAt,
          updated_at: t.updatedAt,
          created_by: (t.createdBy?.id as number) ?? (currentUserId || 1),
          assigned_to: null,
          priority: t.priority,
          due_date: t.dueDate ?? null
        }));
      }
      setTodos(nextTodos);
      persistTodosCache(nextTodos);
      log.info('todos_fetched', { count: nextTodos.length, eventId });
    } catch (error) {
      log.error('fetch_todos_error', { error, eventId });
      showError('Failed to load todo items', 'Todo Error');
    } finally {
      setIsLoading(false);
    }
  }, [eventId, persistTodosCache, showError, log]);

  useEffect(() => {
    try {
      const cached = localStorage.getItem(todosCacheKey);
      if (cached) {
        const parsed = JSON.parse(cached) as TodoItem[];
        if (Array.isArray(parsed)) {
          setTodos(parsed);
          setIsLoading(false);
        }
      }
      const cachedTags = localStorage.getItem(tagsCacheKey);
      if (cachedTags) {
        const parsedTags = JSON.parse(cachedTags) as Record<number, string[]>;
        if (parsedTags && typeof parsedTags === 'object') {
          setTagsByTodoId(parsedTags);
        }
      }
    } catch (err) {
      log.warn('local_cache_read_error', { err });
    }

    fetchTodos();
  }, [eventId, todosCacheKey, tagsCacheKey, fetchTodos, log]);

  const handleCreateTodo = useCallback(async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newTodo.title.trim() || isCreating) return;

    setIsCreating(true);
    try {
      const todoData = {
        title: newTodo.title.trim(),
        description: newTodo.description.trim() || null,
        priority: newTodo.priority,
        due_date: newTodo.due_date || null,
        event_id: eventId,
        created_by: currentUserId || 1
      };

      const created = await api.post<unknown>(`/api/events/${eventId}/todos`, todoData);
      let createdTodo: TodoItem;
      if (created && typeof created === 'object' && 'todo' in (created as Record<string, unknown>)) {
        const t = (created as { todo: { id: number; title: string; description?: string | null; priority: 'low' | 'medium' | 'high'; dueDate?: string | null; isCompleted: boolean; createdAt: string; updatedAt: string } }).todo;
        createdTodo = {
          id: t.id,
          event_id: eventId,
          title: t.title,
          description: t.description ?? null,
          is_completed: !!t.isCompleted,
          created_at: t.createdAt,
          updated_at: t.updatedAt,
          created_by: currentUserId || 1,
          assigned_to: null,
          priority: t.priority,
          due_date: t.dueDate ?? null
        };
      } else {
        createdTodo = created as TodoItem;
      }
      
      setTodos(prev => {
        const next = [...prev, createdTodo];
        persistTodosCache(next);
        return next;
      });

      // Apply tags entered during creation (comma-separated)
      const rawTags = newTodo.tagsInput.trim();
      if (rawTags.length > 0) {
        const tags = rawTags.split(',').map(t => t.trim()).filter(Boolean);
        if (tags.length > 0) {
          setTagsByTodoId(prev => {
            const next = { ...prev, [createdTodo.id]: Array.from(new Set(tags)) };
            persistTagsCache(next);
            return next;
          });
        }
      }
      showSuccess('Todo item created successfully');
      log.info('todo_created', { eventId, todoId: createdTodo.id });
      
      // Reset form
      setNewTodo({ title: '', description: '', priority: 'medium', due_date: '', tagsInput: '' });
      setShowAddForm(false);
    } catch (error) {
      log.error('create_todo_error', { error, eventId });
      showError('Failed to create todo item', 'Todo Error');
    } finally {
      setIsCreating(false);
    }
  }, [newTodo, isCreating, eventId, currentUserId, showSuccess, showError, log, persistTodosCache, persistTagsCache]);

  const handleToggleComplete = useCallback(async (todoId: number, isCompleted: boolean) => {
    try {
      await api.put(`/api/events/${eventId}/todos/${todoId}`, { 
        is_completed: !isCompleted 
      });
      
      setTodos(prev => {
        const next = prev.map(todo => 
          todo.id === todoId 
            ? { ...todo, is_completed: !isCompleted, updated_at: new Date().toISOString() }
            : todo
        );
        persistTodosCache(next);
        return next;
      });
      
      log.info('todo_toggled', { eventId, todoId, completed: !isCompleted });
    } catch (error) {
      log.error('toggle_todo_error', { error, eventId, todoId });
      showError('Failed to update todo item', 'Todo Error');
    }
  }, [eventId, showError, log, persistTodosCache]);

  const handleDeleteTodo = useCallback(async (todoId: number) => {
    if (!isOrganizer) return;
    
    try {
      await api.del(`/api/events/${eventId}/todos/${todoId}`);
      setTodos(prev => {
        const next = prev.filter(todo => todo.id !== todoId);
        persistTodosCache(next);
        return next;
      });
      setTagsByTodoId(prev => {
        const rest = Object.fromEntries(Object.entries(prev).filter(([key]) => Number(key) !== todoId));
        persistTagsCache(rest as Record<number, string[]>);
        return rest as Record<number, string[]>;
      });
      showSuccess('Todo item deleted successfully');
      log.info('todo_deleted', { eventId, todoId });
    } catch (error) {
      log.error('delete_todo_error', { error, eventId, todoId });
      showError('Failed to delete todo item', 'Todo Error');
    }
  }, [isOrganizer, eventId, showSuccess, showError, log, persistTodosCache, persistTagsCache]);

  const getPriorityColor = (priority: TodoItem['priority']) => {
    switch (priority) {
      case 'high': return 'text-red-600 bg-red-50 border-red-200';
      case 'medium': return 'text-yellow-600 bg-yellow-50 border-yellow-200';
      case 'low': return 'text-green-600 bg-green-50 border-green-200';
      default: return 'text-gray-600 bg-gray-50 border-gray-200';
    }
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString();
  };

  const isOverdue = (dueDate: string | null) => {
    if (!dueDate) return false;
    return new Date(dueDate) < new Date();
  };

  const completedTodos = useMemo(() => todos.filter(todo => todo.is_completed), [todos]);
  const incompleteTodos = useMemo(() => todos.filter(todo => !todo.is_completed), [todos]);
  const completionRate = useMemo(() => (
    todos.length > 0 ? Math.round((completedTodos.length / todos.length) * 100) : 0
  ), [todos, completedTodos.length]);

  // Reminders: notify 1 hour before due date and when overdue
  useEffect(() => {
    // Clear existing timers
    Object.values(reminderTimersRef.current).forEach(id => window.clearTimeout(id));
    reminderTimersRef.current = {};

    todos.forEach(todo => {
      if (!todo.due_date || todo.is_completed) return;
      const due = new Date(todo.due_date).getTime();
      if (Number.isNaN(due)) return;

      const now = Date.now();
      const oneHourBefore = due - 60 * 60 * 1000;

      if (due <= now) {
        showError(`Task "${todo.title}" is overdue`, 'Due Date Reminder');
        return;
      }

      if (oneHourBefore > now) {
        const ms = oneHourBefore - now;
        const id = window.setTimeout(() => {
          showSuccess(`Upcoming task: "${todo.title}" due in 1 hour`);
        }, ms);
        reminderTimersRef.current[todo.id] = id;
      }
    });

    return () => {
      Object.values(reminderTimersRef.current).forEach(id => window.clearTimeout(id));
      reminderTimersRef.current = {};
    };
  }, [todos, showSuccess, showError]);

  const sortFn = useCallback((a: TodoItem, b: TodoItem) => {
    if (sortBy === 'priority') {
      const order = { high: 0, medium: 1, low: 2 } as const;
      return order[a.priority] - order[b.priority];
    }
    if (sortBy === 'due_date') {
      const ad = a.due_date ? new Date(a.due_date).getTime() : Number.POSITIVE_INFINITY;
      const bd = b.due_date ? new Date(b.due_date).getTime() : Number.POSITIVE_INFINITY;
      return ad - bd;
    }
    const at = new Date(a.created_at).getTime();
    const bt = new Date(b.created_at).getTime();
    return at - bt;
  }, [sortBy]);

  const filteredIncomplete = useMemo(() => {
    return incompleteTodos
      .filter(t => t.title.toLowerCase().includes(searchQuery.toLowerCase()) || (t.description || '').toLowerCase().includes(searchQuery.toLowerCase()))
      .sort(sortFn);
  }, [incompleteTodos, searchQuery, sortFn]);

  const filteredCompleted = useMemo(() => {
    return completedTodos
      .filter(t => t.title.toLowerCase().includes(searchQuery.toLowerCase()) || (t.description || '').toLowerCase().includes(searchQuery.toLowerCase()))
      .sort(sortFn);
  }, [completedTodos, searchQuery, sortFn]);

  if (isLoading) {
    return (
      <div className="rounded-xl border border-gray-200 bg-white p-4">
        <div className="space-y-3">
          <div className="h-4 bg-gray-200 animate-pulse rounded w-1/2"></div>
          <div className="h-3 bg-gray-200 animate-pulse rounded w-3/4"></div>
          <div className="h-3 bg-gray-200 animate-pulse rounded w-1/2"></div>
        </div>
      </div>
    );
  }

  return (
    <div className="rounded-xl border border-gray-200 bg-white">
      {/* Header */}
      <div className="px-4 py-3 border-b border-gray-200">
        <div className="flex items-center justify-between">
          <div>
            <h3 className="text-lg font-semibold text-gray-900">Event Checklist</h3>
            <p className="text-sm text-gray-600">
              {completedTodos.length} of {todos.length} completed ({completionRate}%)
            </p>
          </div>
          <div className="flex items-center gap-2">
            <input
              type="text"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              placeholder="Search tasks"
              className="px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-500"
            />
            <select
              value={sortBy}
              onChange={(e) => setSortBy(e.target.value as 'priority' | 'due_date' | 'created_at')}
              className="px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-500"
              aria-label="Sort tasks"
            >
              <option value="priority">Sort by priority</option>
              <option value="due_date">Sort by due date</option>
              <option value="created_at">Sort by created</option>
            </select>
            {isOrganizer && (
              <Button
                variant="earth"
                size="sm"
                onClick={() => setShowAddForm(!showAddForm)}
              >
                {showAddForm ? 'Cancel' : 'Add Task'}
              </Button>
            )}
          </div>
        </div>
        
        {/* Progress Bar */}
        {todos.length > 0 && (
          <div className="mt-2">
            <div className="w-full bg-gray-200 rounded-full h-2">
              <div 
                className="bg-brand-600 h-2 rounded-full transition-all duration-300"
                style={{ width: `${completionRate}%` }}
              ></div>
            </div>
          </div>
        )}
      </div>

      {/* Add Form */}
      {showAddForm && (
        <div className="px-4 py-3 border-b border-gray-200 bg-gray-50">
          <form onSubmit={handleCreateTodo} className="space-y-3">
            <input
              type="text"
              placeholder="Task title..."
              value={newTodo.title}
              onChange={(e) => setNewTodo(prev => ({ ...prev, title: e.target.value }))}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-500"
              required
            />
            <textarea
              placeholder="Description (optional)..."
              value={newTodo.description}
              onChange={(e) => setNewTodo(prev => ({ ...prev, description: e.target.value }))}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-500"
              rows={2}
            />
            <input
              type="text"
              placeholder="Tags (comma-separated)"
              value={newTodo.tagsInput}
              onChange={(e) => setNewTodo(prev => ({ ...prev, tagsInput: e.target.value }))}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-500"
            />
            <div className="flex gap-3">
              <select
                value={newTodo.priority}
                onChange={(e) => setNewTodo(prev => ({ ...prev, priority: e.target.value as TodoItem['priority'] }))}
                className="px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-500"
              >
                <option value="low">Low Priority</option>
                <option value="medium">Medium Priority</option>
                <option value="high">High Priority</option>
              </select>
              <input
                type="date"
                value={newTodo.due_date}
                onChange={(e) => setNewTodo(prev => ({ ...prev, due_date: e.target.value }))}
                className="px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-500"
              />
              <Button
                type="submit"
                variant="earth"
                disabled={isCreating}
                className="px-4 py-2"
              >
                {isCreating ? 'Creating...' : 'Create'}
              </Button>
            </div>
          </form>
        </div>
      )}

      {/* Todo Items */}
      <div className="p-4 space-y-3 max-h-96 overflow-y-auto">
        {todos.length === 0 ? (
          <div className="text-center text-gray-500 py-8">
            <svg className="w-12 h-12 mx-auto mb-3 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4" />
            </svg>
            <p>{isOrganizer ? 'No tasks yet. Create your first task!' : 'No tasks assigned yet.'}</p>
          </div>
        ) : (
          <>
            {/* Incomplete Tasks */}
            {filteredIncomplete.length > 0 && (
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <h4 className="text-sm font-medium text-gray-700">To Do ({filteredIncomplete.length})</h4>
                  {isOrganizer && (
                    <Button variant="outline" size="sm" onClick={async () => {
                      const pending = filteredIncomplete.filter(t => !t.is_completed);
                      for (const t of pending) {
                        await handleToggleComplete(t.id, t.is_completed);
                      }
                      showSuccess('All tasks marked complete');
                    }}>Complete all</Button>
                  )}
                </div>
                {filteredIncomplete.map((todo) => (
                  <div key={todo.id} className={`p-3 rounded-lg border ${getPriorityColor(todo.priority)} ${isOverdue(todo.due_date ?? null) ? 'border-red-300 bg-red-50' : ''}`}>
                    <div className="flex items-start gap-3">
                      <input
                        type="checkbox"
                        checked={false}
                        onChange={() => handleToggleComplete(todo.id, todo.is_completed)}
                        className="mt-1 h-4 w-4 text-brand-600 focus:ring-brand-500 border-gray-300 rounded"
                        aria-label={`Mark ${todo.title} as complete`}
                      />
                      <div className="flex-1">
                        <div className="flex items-start justify-between">
                          <div className="flex-1">
                            {editingTodoId === todo.id ? (
                              <div className="space-y-2">
                                <input
                                  type="text"
                                  value={editValues?.title || ''}
                                  onChange={(e) => setEditValues(v => v ? { ...v, title: e.target.value } : v)}
                                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-500"
                                  required
                                />
                                <textarea
                                  value={editValues?.description || ''}
                                  onChange={(e) => setEditValues(v => v ? { ...v, description: e.target.value } : v)}
                                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-500"
                                  rows={2}
                                />
                              </div>
                            ) : (
                              <>
                                <h5 className="font-medium text-gray-900">{todo.title}</h5>
                                {todo.description && (
                                  <p className="text-sm text-gray-600 mt-1">{todo.description}</p>
                                )}
                              </>
                            )}
                            <div className="flex items-center gap-3 mt-2 text-xs text-gray-500">
                              <span className="capitalize">{todo.priority} priority</span>
                              {todo.due_date && (
                                <span className={isOverdue(todo.due_date) ? 'text-red-600 font-medium' : ''}>
                                  Due: {formatDate(todo.due_date)}
                                  {isOverdue(todo.due_date) && ' (Overdue)'}
                                </span>
                              )}
                              {todo.assigned_to ? (
                                <span>Assigned: {todo.assigned_to}</span>
                              ) : null}
                              {/* Tags */}
                              {tagsByTodoId[todo.id]?.length ? (
                                <span className="flex flex-wrap gap-1">
                                  {tagsByTodoId[todo.id].map(tag => (
                                    <span key={tag} className="px-2 py-0.5 bg-teal-100 text-teal-700 rounded-full">#{tag}</span>
                                  ))}
                                </span>
                              ) : null}
                            </div>
                            {editingTodoId === todo.id && (
                              <div className="mt-2 flex gap-2 items-center">
                                <select
                                  value={editValues?.priority || todo.priority}
                                  onChange={(e) => setEditValues(v => v ? { ...v, priority: e.target.value as TodoItem['priority'] } : v)}
                                  className="px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-500"
                                >
                                  <option value="low">Low</option>
                                  <option value="medium">Medium</option>
                                  <option value="high">High</option>
                                </select>
                                <input
                                  type="date"
                                  value={editValues?.due_date || (todo.due_date || '')}
                                  onChange={(e) => setEditValues(v => v ? { ...v, due_date: e.target.value } : v)}
                                  className="px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-500"
                                />
                                <Button
                                  variant="earth"
                                  size="sm"
                                  onClick={async () => {
                                    if (!editValues) return;
                                    try {
                                      const payload = {
                                        title: editValues.title.trim(),
                                        description: editValues.description.trim() || null,
                                        priority: editValues.priority,
                                        due_date: editValues.due_date || null
                                      };
                                      await api.put(`/api/events/${eventId}/todos/${todo.id}`, payload);
                                      setTodos(prev => {
                                        const next = prev.map(t => t.id === todo.id ? { ...t, ...payload, updated_at: new Date().toISOString() } : t);
                                        persistTodosCache(next);
                                        return next;
                                      });
                                      setEditingTodoId(null);
                                      setEditValues(null);
                                      showSuccess('Task updated');
                                    } catch (error) {
                                      log.error('update_todo_error', { error, eventId, todoId: todo.id });
                                      showError('Failed to update task', 'Todo Error');
                                    }
                                  }}
                                >
                                  Save
                                </Button>
                                <Button variant="ghost" size="sm" onClick={() => { setEditingTodoId(null); setEditValues(null); }}>Cancel</Button>
                              </div>
                            )}
                            {/* Tag editor */}
                            {isOrganizer && (
                              <div className="mt-2 flex items-center gap-2">
                                <input
                                  type="text"
                                  placeholder="Add tag"
                                  onKeyDown={(e) => {
                                    const input = (e.target as HTMLInputElement);
                                    if (e.key === 'Enter') {
                                      const t = input.value.trim();
                                      if (t.length === 0) return;
                                      setTagsByTodoId(prev => {
                                        const current = prev[todo.id] || [];
                                        const nextTags = Array.from(new Set([...current, t]));
                                        const next = { ...prev, [todo.id]: nextTags };
                                        persistTagsCache(next);
                                        return next;
                                      });
                                      input.value = '';
                                    }
                                  }}
                                  className="px-2 py-1 border border-gray-300 rounded"
                                />
                                {tagsByTodoId[todo.id]?.map(tag => (
                                  <button
                                    key={`${todo.id}-${tag}`}
                                    onClick={() => {
                                      setTagsByTodoId(prev => {
                                        const current = prev[todo.id] || [];
                                        const nextTags = current.filter(t => t !== tag);
                                        const next = { ...prev, [todo.id]: nextTags };
                                        persistTagsCache(next);
                                        return next;
                                      });
                                    }}
                                    className="text-teal-700 hover:text-teal-900 text-xs"
                                    title={`Remove #${tag}`}
                                  >
                                    remove #{tag}
                                  </button>
                                ))}
                              </div>
                            )}
                          </div>
                          {isOrganizer && (
                            <button
                              onClick={() => handleDeleteTodo(todo.id)}
                              className="text-red-500 hover:text-red-700 p-1"
                              title="Delete task"
                            >
                              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                              </svg>
                            </button>
                          )}
                          <button
                            className="text-xs text-brand-700 hover:text-brand-900"
                            onClick={() => {
                              setEditingTodoId(todo.id);
                              setEditValues({ title: todo.title, description: todo.description || '', priority: todo.priority, due_date: todo.due_date || '' });
                            }}
                          >
                            Edit
                          </button>
                        </div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            )}

            {/* Completed Tasks */}
            {filteredCompleted.length > 0 && (
              <div className="space-y-2 mt-4">
                <div className="flex items-center justify-between">
                  <h4 className="text-sm font-medium text-gray-700">Completed ({filteredCompleted.length})</h4>
                  {isOrganizer && (
                    <Button variant="outline" size="sm" onClick={async () => {
                      if (!confirm('Clear all completed tasks?')) return;
                      for (const t of filteredCompleted) {
                        await handleDeleteTodo(t.id);
                      }
                      showSuccess('Completed tasks cleared');
                    }}>Clear completed</Button>
                  )}
                </div>
                {filteredCompleted.map((todo) => (
                  <div key={todo.id} className="p-3 rounded-lg border border-green-200 bg-green-50">
                    <div className="flex items-start gap-3">
                      <input
                        type="checkbox"
                        checked={true}
                        onChange={() => handleToggleComplete(todo.id, todo.is_completed)}
                        className="mt-1 h-4 w-4 text-green-600 focus:ring-green-500 border-gray-300 rounded"
                        aria-label={`Mark ${todo.title} as incomplete`}
                      />
                      <div className="flex-1">
                        <div className="flex items-start justify-between">
                          <div className="flex-1">
                            <h5 className="font-medium text-gray-900 line-through">{todo.title}</h5>
                            {todo.description && (
                              <p className="text-sm text-gray-600 mt-1 line-through">{todo.description}</p>
                            )}
                            <div className="flex items-center gap-3 mt-2 text-xs text-gray-500">
                              <span className="capitalize">{todo.priority} priority</span>
                              <span>Completed</span>
                            </div>
                          </div>
                          {isOrganizer && (
                            <button
                              onClick={() => handleDeleteTodo(todo.id)}
                              className="text-red-500 hover:text-red-700 p-1"
                              title="Delete task"
                            >
                              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                              </svg>
                            </button>
                          )}
                        </div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
};

export default TodoListComponent;